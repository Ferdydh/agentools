from typing import Type, Optional, Callable
import inspect
import json
from functools import wraps

from docstring_parser import parse
from pydantic import BaseModel, Field, create_model, ValidationError
import jsonref

from .api import Function


#================ User-Defined Tools =================#

class Toolkit:
    '''
    A base class for a collection of tools and their shared states.
    Simply inherit this class and mark your methods as tools with the `@function_tool` decorator.
    After instantiating your toolkit, you can either:
    - [Code]: Simply use the functions as normal, e.g. `toolkit.my_tool(**args)`
    - [Model]: Use the `toolkit.lookup` dict to call the function by name, e.g. `toolkit.lookup['my_tool'](args)`
    '''
    @property
    def lookup(self) -> dict[str, Callable]:
        '''dict of TOOL NAME to argument-validated function'''
        return {
            tool.name: self._with_self(tool.validate_and_call)
            for tool in self._function_tools.values()
        }
    
    @property
    def schema(self) -> list[dict]:
        '''list of OpenAI function schemas'''
        return [tool.schema for tool in self._function_tools.values()]
    
    @property
    def _function_tools(self) -> dict[str, Callable]:
        '''dict of RAW FUNCTION NAME to function'''
        return {
            attr: getattr(self, attr)
            for attr in dir(type(self))
            if not isinstance(getattr(type(self), attr), property)
            and getattr(getattr(self, attr), 'tool_enabled', False)
        }
    
    # util to prevent late-binding of func in a dict comprehension
    def _with_self(self, func: Callable):
        '''Make a function which automatically receives self as the first argument'''
        def wrapper(**kwargs):
            return func({'self': self, **kwargs})
        return wrapper




#================ Decorators =================#

def function_tool(function=None, *, name: Optional[str] = None, check_description: bool = True):
    '''
    Simple decorator that:
    - Marks a function as a tool and enables it: `func.tool_enabled = True`
    - Attaches a lookup dict for OpenAI: `func.lookup = {func.name: func}`
    - Attaches an OpenAI tool schema: `func.schema = {...}`
    - Attaches a pydantic argument validator: `func.validator`
    - Attaches a validate and call function: `func.validate_and_call(args)`
    - If a name is not specified, use the function name as the tool name
    '''
    def decorator(func):
        def validate_and_call(args: dict) -> str:
            try:
                args_without_self = {k: v for k, v in args.items() if k != 'self'}
                func.validator(**args_without_self)
            except ValidationError as e:
                return f'Invalid Argument: {e}'
            return func(**args)
        
        func.name = name or func.__name__
        func.tool_enabled = True
        func.validator = function_to_validator(func, name=func.name, check_description=check_description)
        func.schema = schema_to_openai_func(func.validator)
        func.validate_and_call = validate_and_call
        func.lookup = {func.name: func.validate_and_call}
        return func
    
    if function: # user did `@function_tool`, i.e. we were used directly as a decorator
        return decorator(function)
    else: # user did `@function_tool()` or `@function_tool(name='foo')`
        return decorator


def fail_with_message(message, include_exception=True, logger: Callable = print):
    '''A decorator that catches exceptions from synchronous and asynchronous functions and returns the given message instead. Useful for agent tools.'''

    def log_exception(func, args, kwargs, e):
        if logger:
            logger(f"Tool call {func.__name__}({', '.join(list(map(repr, args)) + [f'{k}={repr(v)}' for k,v in kwargs.items()])}) failed: {e}")
        return message + (f': {str(e)}' if include_exception else '')

    def decorator(func):
        if inspect.iscoroutinefunction(func):
            @wraps(func)
            async def async_wrapper(*args, **kwargs):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    return log_exception(func, args, kwargs, e)
            return async_wrapper
        else:
            @wraps(func)
            def sync_wrapper(*args, **kwargs):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    return log_exception(func, args, kwargs, e)
            return sync_wrapper
    return decorator



#================ Model =================#

async def call_requested_function(call_request: Function, func_lookup: dict[str, Callable]):
    '''
    Call the requested function generated by the model.
    '''
    # parse function call
    func_name = call_request.name
    arguments = call_request.arguments

    if func_name not in func_lookup:
        return f"Error: Function {func_name} does not exist."
    try:
        args = json.loads(arguments)
    except Exception as e:    
        return f"Error: Failed to parse arguments, make sure your arguments is a valid JSON object: {e}"

    # call function
    try:
        return_value = func_lookup[func_name](**args)
        # if it's a coroutine, await it
        if inspect.iscoroutine(return_value):
            print("awaiting coroutine")
            return await return_value
        else:
            return return_value
    except Exception as e:
        return f"Error: {e}"


#================ Utils =================#

# Function -> Pydantic model
def function_to_validator(func: Callable, name: Optional[str] = None, check_description = True) -> type[BaseModel]:
    '''
    Convert a function to a pydantic model for validation of function parameters.

    Args:
        func: function to convert
        name: name of the model, defaults to func.__name__

    Returns:
        pydantic model
    '''
    sig: inspect.Signature = inspect.signature(func)
    doc = parse(inspect.getdoc(func) or "")

    # get function name
    name = name or func.__name__

    # get general function description
    summary = f"{doc.short_description or ''}\n{doc.long_description or ''}".strip()

    # {param_name: param_description}
    param_descriptions = {
        doc_param.arg_name: doc_param.description
        for doc_param in doc.params
    }

    # convert function parameters to pydantic model fields
    model_fields = {}

    for param in sig.parameters.values():
        if param.name in ["self", "return", "return_type"]:
            continue

        if check_description:
            assert param.name in param_descriptions, (f"Missing description for parameter {param.name} in {func.__name__}'s docstring!")
        
        assert param.annotation != inspect.Parameter.empty, (f"Missing type annotation for parameter {param.name} in {func.__name__}!")
            
        model_fields[param.name] = (
            param.annotation, # type
            Field(
                title=None,
                description=param_descriptions.get(param.name),
                default=
                    ...
                    if param.default is inspect.Parameter.empty
                    else param.default,
            ),
        )

    # create a pydantic model for function argument validation
    model = create_model(name, __doc__=summary or None, **model_fields)
    return model


# Pydantic/JSON Schema -> OpenAI function schema
def schema_to_openai_func(schema: dict | Type[BaseModel], nested=True) -> dict:
    if not isinstance(schema, dict) and issubclass(schema, BaseModel):
        if nested:
            schema = to_nested_schema(schema, no_title=False)
        else:
            schema = schema.model_json_schema()

    # Convert properties
    remove_title(schema['properties'])

    # Construct the OpenAI function schema format
    return {
        'type': 'function',
        "function": {
            'name': schema['title'],
            **({'description': d} if (d:=schema.get('description')) else {}),
            'parameters': {
                'type': 'object',
                'properties': schema['properties'],
                'required': schema.get('required', [])
            }
        }
    }


def to_nested_schema(model: Type[BaseModel], no_title=True) -> dict:
    '''nested json schema rather than refs'''
    schema = jsonref.loads(json.dumps(model.model_json_schema()), proxies=False)
    if 'definitions' in schema:
        schema.pop('definitions')
    if '$defs' in schema:
        schema.pop('$defs')
    if no_title:
        remove_title(schema)
    return schema

def remove_title(d) -> dict | list:
    if isinstance(d, dict):
        if 'title' in d and type(d['title']) == str:
            d.pop('title')
        for v in d.values():
            remove_title(v)
    elif isinstance(d, list):
        for v in d:
            remove_title(v)
    return d
